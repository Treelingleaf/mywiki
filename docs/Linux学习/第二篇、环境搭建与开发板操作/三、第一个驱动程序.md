# 三、第一个驱动程序

1. 配置编译：内核、设备树、驱动
2. 放到开发板上
3. 编译、测试第一个驱动程序

# 1. 编译内核和设备树

找到内核所在目录执行下面指令：

```shell
make mrproper
make 100ask_imx6ull_defconfig
make zImage -j4
make dtbs
```

> 1. ​`make mrproper`​:
>
>     * 这个命令通常用于清除之前的配置和生成的文件，以确保内核编译是从干净的状态开始的。它会删除之前生成的配置文件、编译结果等。
> 2. ​`make 100ask_imx6ull_defconfig`​:
>
>     * 这个命令用于配置内核，使用名为 `100ask_imx6ull_defconfig`​ 的内核配置文件。这个配置文件通常是特定于你的开发板或硬件平台的。它会为内核提供一组默认配置选项，以适应特定的硬件需求。
> 3. ​`make zImage -j4`​:
>
>     * 这个命令用于编译内核，生成 `zImage`​ 内核镜像文件。`-j4`​ 选项表示使用四个并发任务进行编译，以加快编译速度。`zImage`​ 是一种用于 ARM 架构的压缩内核映像。
> 4. ​`make dtbs`​:
>
>     * 这个命令用于编译设备树二进制文件（Device Tree Blob）。设备树文件是描述硬件配置的文件，它们在嵌入式 Linux 系统中用于描述硬件组件的信息。这些信息在内核启动时用于配置硬件。编译设备树文件非常重要，因为它们描述了你的特定硬件平台的硬件配置。

‍

> **提一嘴内核移植，上面的过程和内核移植大差不差，就是移植的内核是已经配置好的内核：**

内核移植是将 Linux 内核适配到新的硬件平台或设备上的过程。这需要一些工作和步骤，以确保内核能够在新硬件上正常运行。以下是一般的内核移植工作：

1. **获取内核源代码：**  获取适当版本的 Linux 内核源代码，通常是从 Linux 内核官方网站或相关资源仓库中获取。
2. **配置内核选项：**  使用 `make menuconfig`​、`make xconfig`​ 或 `make config`​ 等工具，配置内核选项以匹配新硬件平台的需求。这包括选择适当的体系结构、设备驱动、文件系统支持、网络协议等。
3. **修改硬件相关代码：**  如果新硬件与现有内核代码不兼容，可能需要修改内核的硬件相关代码，以支持新硬件设备。这可能包括更改寄存器设置、中断处理、时钟设置等。
4. **添加设备树支持：**  如果你的硬件平台使用设备树描述（Device Tree）来描述硬件配置，你需要创建或修改设备树文件以描述新硬件平台的硬件组件。
5. **编译内核：**  使用交叉编译工具链编译内核，生成适用于新硬件平台的内核映像文件。
6. **设置引导加载程序（Bootloader）：**  配置引导加载程序以引导新内核。这可能涉及到更新引导加载程序的配置文件，如 U-Boot 的 `uEnv.txt`​。
7. **测试启动：**  将编译后的内核映像文件和设备树文件传输到新硬件上，然后启动硬件以测试内核是否能够正常启动。
8. **调试和修复问题：**  如果内核不能正常启动，需要进行调试，查找并修复问题。这可能包括内核日志分析、中断问题、设备驱动问题等。
9. **配置硬件设备：**  配置和测试硬件设备，确保它们与新内核协同工作。这包括网络设置、存储设备、输入设备等。
10. **编写或修改设备驱动：**  如果新硬件需要特定的设备驱动程序，你可能需要编写或修改适当的设备驱动代码。
11. **性能优化：**  针对新硬件平台进行性能优化，以确保内核能够充分利用硬件资源。
12. **文档和维护：**  编写适当的文档，以记录移植的过程、硬件配置和特殊需求。此外，维护内核代码以保持与新硬件平台的兼容性。

‍

# 2. 编译内核模块

```shell
make modules
#安装内核模块到ubuntu的某个目录下
make ARCH=arm INSTALL_MOD_PATH=/home/hqyj/imx6ull modules_install
```

> **什么是内核模块？**

内核模块通常是驱动程序的一种。内核模块是 Linux 内核中的可加载模块，它们用于扩展内核的功能，包括支持设备驱动、文件系统、网络协议、虚拟文件系统等。

驱动程序是内核模块的一个主要用途之一。设备驱动程序是一种内核模块，它与特定硬件设备通信，允许操作系统与硬件设备进行交互。设备驱动程序通常包括以下功能：

1. **设备初始化和配置：**  驱动程序负责初始化硬件设备，配置设备的寄存器和参数等。
2. **设备数据传输：**  驱动程序允许操作系统和应用程序与设备进行数据传输，包括读取和写入数据。
3. **中断处理：**  驱动程序通常包括中断处理程序，以便及时响应设备生成的中断信号。
4. **设备状态管理：**  驱动程序跟踪设备的状态，例如打开、关闭、暂停、恢复等操作。
5. **提供设备接口：**  驱动程序向用户空间提供设备接口，允许应用程序通过文件操作来访问和控制设备。

内核模块的好处是它们可以在运行时加载和卸载，而无需重新编译内核。这使得在不重启系统的情况下添加、更新或删除设备驱动变得更加灵活。内核模块还提供了一种模块化的方法，允许开发者将特定功能的代码独立地组织为模块，以简化内核的管理和维护。

除了设备驱动之外，内核模块还可以用于实现其他功能，如文件系统、网络协议栈扩展、虚拟文件系统、安全模块等。因此，内核模块在 Linux 系统中扮演了非常重要的角色，允许操作系统适应各种硬件和应用程序需求。

‍

# 3. 将编译好的模块放进开发板

这里还是采用NFS挂载方式传输文件

> **把zImage(内核镜像文件)和100ask_imx6ull-14x14.dtb(设备树文件)放到开发板的/boot目录**
>
> **把modules(内核模块)放到开发板的/lib目录**

```shell
cp /mnt/zImage /boot
cp /mnt/100ask_imx6ull-14x14.dtb /boot
cp /mnt/lib/modules /lib -rfd
sync  
#sync是同步作用
```

‍

# 4. 编译驱动程序

**一般来说编译一个驱动程序的步骤：**

> 1. **编写驱动代码：**  开发者编写设备驱动程序的源代码。这包括初始化、设备操作、中断处理、资源分配和释放等。
> 2. **配置内核选项：**  在内核配置中，确保已启用了与设备相关的配置选项。这可能需要使用 `make menuconfig`​ 或其他内核配置工具来选择正确的配置选项。
> 3. **编译驱动程序：**  使用内核源代码和交叉编译工具链，编译设备驱动程序。这通常会生成一个或多个共享库或内核模块文件。
> 4. **加载驱动程序：**  将编译的驱动程序加载到运行中的内核中。这可以使用 `insmod`​、`modprobe`​ 或其他加载模块的命令来完成。
> 5. **测试驱动程序：**  验证驱动程序与设备的交互是否正常。测试包括读写设备、处理中断、设备初始化等。
> 6. **调试和修复问题：**  如果驱动程序在加载或运行时遇到问题，进行调试并修复问题。这可能包括查看内核日志、使用 `dmesg`​ 命令，以及修改驱动代码。
> 7. **卸载驱动程序：**  当不再需要该驱动程序时，使用 `rmmod`​ 命令卸载它，以释放系统资源。

进入git仓库的第一个驱动程序目录

其中包含了驱动源码和用户空间的测试程序源码，还有一个makefile，解读一下这个makefile：

```makefile
# 1. 使用不同的开发板内核时, 一定要修改KERN_DIR
# 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:
# 2.1 ARCH,          比如: export ARCH=arm64
# 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-
# 2.3 PATH,          比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin
# 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,
#       请参考各开发板的高级用户使用手册

KERN_DIR = /home/hqyj/100ask_imx6ull-sdk/Linux-4.9.88

all:
        make -C $(KERN_DIR) M=`pwd` modules
        $(CROSS_COMPILE)gcc -o hello_drv_test hello_drv_test.c

clean:
        make -C $(KERN_DIR) M=`pwd` modules clean
        rm -rf modules.order
        rm -f hello_drv_test

obj-m   += hello_drv.o
```

> **先明白驱动程序一般是怎么编译的：**

通常情况下，编写和编译设备驱动程序需要借助内核源代码中的 Makefile 来进行编译。这是因为设备驱动程序是内核的一部分，它们依赖于内核的数据结构、接口和函数，因此需要与内核一起编译。

> **然后解释上面的makefile：**

​`make -C $(KERN_DIR) M=$(PWD) modules`​ 是一个 Makefile 中常见的用于编译内核模块的命令，它用于在指定的内核源代码目录中编译指定目录中的模块。让我为你解释其中的每个部分：

* ​`make`​: 这是用于调用 GNU Make 工具的命令，它负责执行 Makefile 中定义的编译规则。
* ​`-C $(KERN_DIR)`​: 这是一个 Make 命令的选项，`-C`​ 用于指定在哪个目录中执行 Makefile。`$(KERN_DIR)`​ 是一个变量，代表了内核源代码目录的路径。所以 `-C $(KERN_DIR)`​ 意味着在内核源代码目录中执行 Makefile。
* ​`M=$(PWD)`​: 这是另一个选项，`M`​ 用于指定要编译的模块所在的目录。`$(PWD)`​ 是一个环境变量，代表当前工作目录（Makefile 所在的目录）。因此，`M=$(PWD)`​ 意味着要编译当前工作目录中的模块。
* ​`modules`​: 这是 Makefile 中的目标，它告诉 Make 工具执行与编译内核模块相关的规则。

综合起来，这个命令的作用是告诉 Make 工具进入内核源代码目录 `$(KERN_DIR)`​，然后执行内核源代码中的 Makefile 中定义的与编译内核模块相关的规则，这些规则通常包括了编译内核模块所需的步骤。`M=$(PWD)`​ 部分确保只编译当前工作目录中的模块，而不会影响内核的其他部分

‍

> **编译好驱动后就是装载驱动到开发板：**

使用命令`insmod`​：

```makefile
insmod hello_drv.ko
```

卸载驱动：

```makefile
rmmod hello_drv
```

查看已安装驱动：

```makefile
lsmod
```

‍
