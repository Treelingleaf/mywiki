# UCOSIII中信号量、消息队列、互斥量相关API

# 1. **信号量**

[https://blog.csdn.net/qq_38410730/article/details/80848586](https://blog.csdn.net/qq_38410730/article/details/80848586)

**常用的API:**

|**OSSemCreate()**|**创建一个信号量**|
| --| --|
|**OSSemDel()**|**删除一个信号量**|
|**OSSemPend()**|**等待一个信号量**|
|**OSSemPendAbort()**|**取消等待**|
|**OSSemPost()**|**释放一个信号量**|
|**OSSemSet()**|**强制设置一个信号量的值**|

**详细说明:**

## 1.1. **创建一个信号量-&gt;OSSemCreate**

```c
/*******************************************************************************
函数名称: OSSemCreate

描述:
    该函数用于在实时操作系统（RTOS）环境中创建用于同步和互斥的信号量。
  
参数:
    p_sem（输出）：一个指向 `OS_SEM` 类型变量的指针，将保存创建的信号量的句柄。

    p_name（可选）：一个指向字符数组的指针，用于指定信号量的名称，用于调试和跟踪。该参数是可选的，如果不需要可以设置为 NULL。

    cnt：信号量的初始计数值，表示初始可用资源的数量。

    p_err（输出）：一个指向 `OS_ERR` 类型变量的指针，将存储函数执行的结果。在成功执行后，`p_err` 将包含 `OS_ERR_NONE`，表示没有错误。

返回值:
    无

*******************************************************************************/
OS_ERR OSSemCreate(OS_SEM    *p_sem,        // 信号量句柄指针
                   CPU_CHAR  *p_name,       // 信号量名称（可选）
                   OS_SEM_CTR cnt,          // 信号量的初始计数值
                   OS_ERR    *p_err);       // 函数执行结果存储变量
```

## 1.2. **删除一个信号量-&gt;OSSemDel**

```c
/*******************************************************************************

函数名称: OSSemDel

描述:
    该函数用于删除一个已经创建的信号量。

参数:
    p_sem（输入/输出）：一个指向 `OS_SEM` 类型变量的指针，指向要删除的信号量的句柄。
  
    opt（输入）：删除选项，指定了删除信号量时的行为。可以选择以下选项之一：
        - `OS_OPT_DEL_NO_PEND`：如果有任务挂起等待此信号量，则不允许删除，并返回错误。
        - `OS_OPT_DEL_ALWAYS`：不管是否有任务挂起等待此信号量，都删除信号量。

    p_err（输出）：一个指向 `OS_ERR` 类型变量的指针，将存储函数执行的结果。在成功执行后，`p_err` 将包含 `OS_ERR_NONE`，表示没有错误。如果删除失败，将根据情况包含其他错误代码。

返回值:
    无

*******************************************************************************/
OS_ERR OSSemDel(OS_SEM   *p_sem,            // 信号量句柄指针
                OS_OPT    opt,              // 删除选项
                OS_ERR   *p_err);          // 函数执行结果存储变量
```

## 1.3. **等待一个信号量-&gt;OSSemPend**

```c
/*******************************************************************************

函数名称: OSSemPend

描述:
    该函数用于请求等待一个信号量。

参数:
    p_sem（输入/输出）：一个指向 `OS_SEM` 类型变量的指针，指向要等待的信号量的句柄。
  
    timeout（输入）：等待的最长时间，以时钟节拍数为单位。如果设置为 0，表示无限等待。
  
    opt（输入）：等待选项，指定了等待信号量时的行为。可以选择以下选项之一：
        - `OS_OPT_PEND_BLOCKING`：如果信号量不可用，则任务将被阻塞，等待信号量变为可用。
        - `OS_OPT_PEND_NON_BLOCKING`：如果信号量不可用，任务不会被阻塞，而是立即返回错误。

    p_ts（输出，可选）：一个指向 `CPU_TS` 类型变量的指针，用于存储时间戳。时间戳表示等待信号量的开始时间。这是一个可选参数，可以为 NULL，如果不需要时间戳信息。

    p_err（输出）：一个指向 `OS_ERR` 类型变量的指针，将存储函数执行的结果。在成功执行后，`p_err` 将包含 `OS_ERR_NONE`，表示没有错误。如果等待信号量失败，将根据情况包含其他错误代码。

返回值:
    无

*******************************************************************************/
OS_ERR OSSemPend(OS_SEM   *p_sem,            // 信号量句柄指针
                 OS_TICK  timeout,           // 等待的最长时间
                 OS_OPT   opt,              // 等待选项
                 CPU_TS  *p_ts,             // 时间戳指针（可选）
                 OS_ERR  *p_err);           // 函数执行结果存储变量
```

## 1.4. **取消等待-&gt;OSSemPendAbort**

```c
/*******************************************************************************

函数名称: OSSemPendAbort

描述:
    该函数用于中止等待信号量的任务。如果有任务正在等待信号量，它们将被唤醒并返回错误代码。

参数:
    p_sem（输入）：一个指向 `OS_SEM` 类型变量的指针，指向等待的信号量的句柄。
  
    opt（输入）：选项，指定了中止等待信号量的任务的行为。可以选择以下选项之一：
        - `OS_OPT_PEND_ABORT_1`：中止等待信号量的第一个任务。
        - `OS_OPT_PEND_ABORT_ALL`：中止等待信号量的所有任务。

    p_err（输出）：一个指向 `OS_ERR` 类型变量的指针，将存储函数执行的结果。在成功执行后，`p_err` 将包含 `OS_ERR_NONE`，表示没有错误。如果中止等待失败，将根据情况包含其他错误代码。

返回值:
    无

*******************************************************************************/
void OSSemPendAbort(OS_SEM   *p_sem,     // 信号量句柄指针
                    OS_OPT    opt,       // 选项
                    OS_ERR   *p_err);    // 函数执行结果存储变量
  
```

## 1.5. **释放一个信号量-&gt;OSSemPost**

```c
/*******************************************************************************

函数名称: OSSemPost

描述:
    该函数用于释放（发放）一个信号量。

参数:
    p_sem（输入）：一个指向 `OS_SEM` 类型变量的指针，指向要释放的信号量的句柄。
  
    opt（输入）：释放选项，指定了释放信号量时的行为。可以选择以下选项之一：
        - `OS_OPT_POST_NONE`：无特殊选项。
        - `OS_OPT_POST_NO_SCHED`：释放信号量后，不要立即进行任务调度，即不要立即检查是否有等待此信号量的任务可以运行。
        - `OS_OPT_POST_ISR`：该信号量是在中断服务程序（ISR）中释放的。

    p_err（输出）：一个指向 `OS_ERR` 类型变量的指针，将存储函数执行的结果。在成功执行后，`p_err` 将包含 `OS_ERR_NONE`，表示没有错误。如果释放信号量失败，将根据情况包含其他错误代码。

返回值:
    无

*******************************************************************************/
OS_ERR OSSemPost(OS_SEM *p_sem,             // 信号量句柄指针
                 OS_OPT  opt,               // 释放选项
                 OS_ERR *p_err);           // 函数执行结果存储变量
```

## 1.6. **强制设置一个信号量的值-&gt;OSSemSet**

```c
/*******************************************************************************

函数名称: OSSemSet

描述:
    该函数用于设置信号量的计数值。它将信号量的计数值更改为指定的新值。

参数:
    p_sem（输入）：一个指向 `OS_SEM` 类型变量的指针，指向要设置的信号量的句柄。
  
    value（输入）：新的信号量计数值，将替代当前的计数值。

    p_err（输出）：一个指向 `OS_ERR` 类型变量的指针，将存储函数执行的结果。在成功执行后，`p_err` 将包含 `OS_ERR_NONE`，表示没有错误。如果设置信号量失败，将根据情况包含其他错误代码。

返回值:
    无

*******************************************************************************/
OS_ERR OSSemSet(OS_SEM    *p_sem,          // 信号量句柄指针
                OS_SEM_CTR value,          // 新的信号量计数值
                OS_ERR   *p_err);         // 函数执行结果存储变量
```

# 2. **互斥量**

[https://blog.csdn.net/qq_38410730/article/details/80878292](https://blog.csdn.net/qq_38410730/article/details/80878292)

**常用API:**

|**OSMutexCreate()**|**创建一个互斥信号量**|
| --| --|
|**OSMutexDel()**|**删除一个互斥型信号量**|
|**OSMutexPend()**|**等待一个互斥型信号量**|
|**OSMutexPendAbort()**|**取消等待**|
|**OSMutexPost()**|**释放一个互斥型信号量**|

**详细说明:**

## 2.1. **创建一个互斥量-&gt;OSMutexCreate**

```c
/*******************************************************************************
* 函数名: OSMutexCreate
* 描  述: 创建互斥量
* 输  入:
*            p_mutex     互斥量句柄指针
*            p_name      互斥量名称（可选）
* 输  出:
*            p_err       函数执行结果存储变量
* 返回值: 无
* 注意事项: 互斥量是用于控制多任务访问共享资源的机制，确保在任何时刻只有一个任务可以访问共享资源。
*******************************************************************************/
OS_ERR OSMutexCreate(OS_MUTEX     *p_mutex,      // 互斥量句柄指针
                     CPU_CHAR     *p_name,       // 互斥量名称（可选）
                     OS_ERR      *p_err);       // 函数执行结果存储变量
```

## 2.2. **删除一个互斥量-&gt;OSMutexDel**

```c
/*******************************************************************************
* 函数名: OSMutexDel
* 描  述: 删除互斥量
* 输  入:
*            p_mutex     互斥量句柄指针
*            opt         删除选项，可以选择以下选项之一：
*                        - OS_OPT_DEL_NO_PEND: 如果互斥量当前未被持有，则删除互斥量。
*                        - OS_OPT_DEL_ALWAYS: 无论互斥量当前是否被持有，都删除互斥量。
*            p_err       函数执行结果存储变量
* 输  出: 无
* 返回值: 无
* 注意事项: 删除互斥量，并释放相关资源。
*******************************************************************************/
OS_ERR OSMutexDel(OS_MUTEX *p_mutex,
                  OS_OPT    opt,
                  OS_ERR   *p_err);
```

## 2.3. **等待一个互斥信号量-&gt;OSMutexPend**

```c
/*******************************************************************************
* 函数名: OSMutexPend
* 描  述: 请求互斥量
* 输  入:
*            p_mutex     互斥量句柄指针
*            timeout     等待的最长时间（以时钟节拍数为单位），如果设置为0则表示无限等待。
*            opt         等待选项，可以选择以下选项之一：
*                        - OS_OPT_PEND_BLOCKING: 阻塞等待互斥量，直到获得互斥量或超时。
*                        - OS_OPT_PEND_NON_BLOCKING: 非阻塞等待互斥量，如果不能获得互斥量立即返回。
*            p_ts        时间戳指针，用于存储互斥量的持有时间（可选，如果不需要可设置为NULL）。
*            p_err       函数执行结果存储变量
* 输  出: 无
* 返回值: 无
* 注意事项: 请求互斥量，如果互斥量当前被其他任务持有，根据等待选项可能会阻塞当前任务。
*******************************************************************************/
OS_ERR OSMutexPend(OS_MUTEX   *p_mutex,
                   OS_TICK    timeout,
                   OS_OPT     opt,
                   CPU_TS    *p_ts,
                   OS_ERR    *p_err);
```

## 2.4. **取消等待-&gt;OSMutexPendAbort**

```c
/*******************************************************************************
* 函数名: OSMutexPendAbort
* 描  述: 取消等待互斥量的操作
* 输  入:
*            p_mutex     互斥量句柄指针
*            opt         选项，可以选择以下选项之一：
*                        - OS_OPT_PEND_ABORT_NONE: 无特殊选项。
*                        - OS_OPT_PEND_ABORT_1: 取消等待一个任务等待互斥量的操作。
*                        - OS_OPT_PEND_ABORT_ALL: 取消等待所有任务等待互斥量的操作。
*            p_err       函数执行结果存储变量
* 输  出: 无
* 返回值: 无
* 注意事项: 用于取消等待互斥量的操作，可选择取消一个或多个等待操作。
*******************************************************************************/
void OSMutexPendAbort(OS_MUTEX *p_mutex,
                      OS_OPT    opt,
                      OS_ERR   *p_err);
```

## 2.5. **释放一个互斥量-&gt;OSMutexPost**

```c
/*******************************************************************************
* 函数名: OSMutexPost
* 描  述: 释放互斥量
* 输  入:
*            p_mutex     互斥量句柄指针
*            opt         释放选项，可以选择以下选项之一：
*                        - OS_OPT_POST_NONE: 无特殊选项，简单释放互斥量。
*                        - OS_OPT_POST_NO_SCHED: 释放互斥量但不立即进行任务调度。
*                        - OS_OPT_POST_ISR: 该函数由中断服务程序调用。
*            p_err       函数执行结果存储变量
* 输  出: 无
* 返回值: 无
* 注意事项: 释放互斥量，允许其他任务获得互斥量并继续执行。可选择不进行任务调度。
*******************************************************************************/
OS_ERR OSMutexPost(OS_MUTEX *p_mutex,
                   OS_OPT    opt,
                   OS_ERR   *p_err);
```

# 3. **消息队列**

[https://blog.csdn.net/iiiNoName/article/details/105192982](https://blog.csdn.net/iiiNoName/article/details/105192982)

**常用API：**

|**OSQCreate()**|**创建消息队列**|
| --| --|
|**OSQDel()**|**消息队列删除**|
|**OSQPost()**|**消息队列发送**|
|**OSQPend()**|**消息队列获取**|
|**OSQAccept()**|**接收消息（非阻塞）**|

## 3.1. **创建消息队列-&gt;OSQCreate**

```c
/*******************************************************************************
* 函数名: OSQCreate
* 描  述: 创建消息队列
* 输  入:
*            p_q         消息队列指针
*            p_name      消息队列名称（可选）
*            max_qty     消息队列大小，不能为0
*            p_err       函数执行结果存储变量
* 输  出: 无
* 返回值: 无
* 注意事项: 创建一个消息队列，指定其大小，以便用于任务之间的消息传递。
*******************************************************************************/
void OSQCreate(OS_Q      *p_q,         // 消息队列指针
              CPU_CHAR  *p_name,      // 消息队列名称（可选）
              OS_MSG_QTY max_qty,    // 消息队列大小，不能为0
              OS_ERR    *p_err);     // 返回错误类型
```

## 3.2. **消息队列删除-&gt;OSQDel**

```c
/*******************************************************************************
* 函数名: OSQDel
* 描  述: 删除消息队列
* 输  入:
*            p_q         消息队列指针
*            opt         选项（可选参数）
*                            OS_OPT_DEL_NO_PEND  : 无等待删除（如果队列非空则不删除）
*                            OS_OPT_DEL_ALWAYS   : 无论队列是否为空都删除
*                            OS_OPT_DEL_BLOCKING : 阻塞直到队列为空后再删除
*            p_err       函数执行结果存储变量
* 输  出: 无
* 返回值: 无
* 注意事项: 删除消息队列，并释放相关资源。
*******************************************************************************/
OS_OBJ_QTY OSQDel(OS_Q    *p_q,     // 消息队列指针
                 OS_OPT   opt,     // 选项（可选参数）
                 OS_ERR  *p_err);  // 返回错误类型
```

## 3.3. **消息队列发送-&gt;OSQPost**

```c
/*******************************************************************************
* 函数名: OSQPost
* 描  述: 向消息队列中发送消息
* 输  入:
*            p_q         消息队列指针
*            p_void      消息指针
*            msg_size    消息大小（单位：字节）
*            opt         选项（可选参数）
*                            OS_OPT_POST_FIFO   : 将消息插入到队列的末尾（默认）
*                            OS_OPT_POST_LIFO   : 将消息插入到队列的开头
*            p_err       函数执行结果存储变量
* 输  出: 无
* 返回值: 无
* 注意事项: 向消息队列中发送消息。
*******************************************************************************/
void OSQPost(OS_Q         *p_q,      // 消息队列指针
             void         *p_void,   // 消息指针
             OS_MSG_SIZE   msg_size, // 消息大小（单位：字节）
             OS_OPT        opt,      // 选项
             OS_ERR       *p_err);   // 返回错误类型
```

```c
#define OS_OPT_POST_FIFO (OS_OPT)			(0x0000u) /* 默认采用FIFO 方式发送 */
#define OS_OPT_POST_LIFO (OS_OPT)			(0x0010u) /*采用LIFO 方式发送消息*/
#define OS_OPT_POST_1 (OS_OPT)				(0x0000u) /*将消息发布到最高优先级的等待任务*/
#define OS_OPT_POST_ALL (OS_OPT)			(0x0200u) /*向所有等待的任务广播消息*/
#define OS_OPT_POST_NO_SCHED (OS_OPT)		(0x8000u) /*发送消息但是不进行任务调度*/
我们可以使用，上面基本类型来组合出其他几种类型，如下:
OS_OPT_POST_FIFO+ OS_OPT_POST_ALL
OS_OPT_POST_LIFO +OS_OPT_POST_ALL
OS_OPT_POST_FIFO+ OS_OPT_POST_NO_SCHED
OS_OPT_POST_LIFO + OS_OPT_POST_NO_SCHED
OS_OPT_POST_FIFO + OS_OPT_POST_ALL + OS_OPT_POST_NO_SCHED
OS_OPT_POST_LIFO  + OS_OPT_POST_ALL+ OS_OPT_POST_NO_SCHED
```

## 3.4. **消息队列获取-&gt;OSQPend**

```c
/*******************************************************************************
* 函数名: OSQPend
* 描  述: 从消息队列中接收消息
* 输  入:
*            p_q         消息队列指针
*            timeout     等待期限（单位：时钟节拍）
*            opt         选项（可选参数）
*                            OS_OPT_PEND_BLOCKING : 阻塞等待消息（默认）
*                            OS_OPT_PEND_NON_BLOCKING : 非阻塞等待，如果没有消息立即返回
*            p_msg_size  返回消息大小的指针（单位：字节）
*            p_ts        获取等到消息时的时间戳（可选参数）
*            p_err       函数执行结果存储变量
* 输  出: 
*            返回接收到的消息指针
* 返回值: 无
* 注意事项: 从消息队列中接收消息。
*******************************************************************************/
void *OSQPend(OS_Q         *p_q,       // 消息队列指针
              OS_TICK       timeout,   // 等待期限（单位：时钟节拍）
              OS_OPT        opt,       // 选项
              OS_MSG_SIZE  *p_msg_size,// 返回消息大小的指针
              CPU_TS       *p_ts,      // 获取等到消息时的时间戳（可选参数）
              OS_ERR       *p_err);    // 返回错误类型
```

# 4. **任务信号量**

[https://blog.csdn.net/qq_38410730/article/details/80890052](https://blog.csdn.net/qq_38410730/article/details/80890052)

[https://blog.csdn.net/qq_51963216/article/details/123937142](https://blog.csdn.net/qq_51963216/article/details/123937142)

[https://blog.csdn.net/qq_38410730/article/details/80916936](https://blog.csdn.net/qq_38410730/article/details/80916936)

|||
| --| --|
|||
|||

[https://blog.csdn.net/qq_38410730/article/details/80821152](https://blog.csdn.net/qq_38410730/article/details/80821152)
